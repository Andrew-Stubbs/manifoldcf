/* $Id$ *//*** Licensed to the Apache Software Foundation (ASF) under one or more* contributor license agreements. See the NOTICE file distributed with* this work for additional information regarding copyright ownership.* The ASF licenses this file to You under the Apache License, Version 2.0* (the "License"); you may not use this file except in compliance with* the License. You may obtain a copy of the License at** http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.* See the License for the specific language governing permissions and* limitations under the License.*/package org.apache.manifoldcf.agents.output.amazoncloudsearch;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.manifoldcf.core.interfaces.ColumnDescription;import org.apache.manifoldcf.core.interfaces.IDBInterface;import org.apache.manifoldcf.core.interfaces.IResultRow;import org.apache.manifoldcf.core.interfaces.IResultSet;import org.apache.manifoldcf.core.interfaces.IThreadContext;import org.apache.manifoldcf.core.interfaces.ManifoldCFException;import org.apache.manifoldcf.core.interfaces.StringSet;import org.exolab.castor.util.Iterator;public class DocumentChunkManager extends org.apache.manifoldcf.core.database.BaseTable{  // Database fields  private final static String UID_FIELD = "uid";  private final static String ON_DELETE_FIELD = "ondelete";  private final static String SDF_DATA_FIELD = "sdfdata";    private final int MAX_DOCNUM_IN_CHUNK = 5000;  private final int MAX_DOCBYTES_IN_CHUNK = 5242880; //5MB    Map<String, List<String>> uidMap = new HashMap<String, List<String>>();    public DocumentChunkManager(IThreadContext threadContext,      IDBInterface database)  {    super(database, "amazoncloudsearch_documentdata");  }  /** Install the manager    * @throws ManifoldCFException    */  public void install() throws ManifoldCFException  {    // Standard practice: outer loop on install methods, no transactions    while (true)    {      Map existing = getTableSchema(null,null);      if (existing == null)      {        // Install the table.        HashMap map = new HashMap();        map.put(UID_FIELD,new ColumnDescription("VARCHAR(255)",true,false,null,null,false));        map.put(ON_DELETE_FIELD,new ColumnDescription("CHAR(1)",false,false,null,null,false));        map.put(SDF_DATA_FIELD,new ColumnDescription("CLOB",false,true,null,null,false));        performCreate(map,null);      }      else      {        // Upgrade code, if needed, goes here      }      // Handle indexes, if needed            break;    }  }    /** Uninstall the manager.  */  public void deinstall()    throws ManifoldCFException  {    performDrop(null);  }    /** Perform a table creation operation.  *@param columnMap is the map describing the columns and types.  NOTE that these are abstract  * types, which will be mapped to the proper types for the actual database inside this  * layer.  *@param invalidateKeys are the cache keys that should be invalidated, if any.  */  protected void performCreate(Map columnMap, StringSet invalidateKeys)    throws ManifoldCFException  {    dbInterface.performCreate(tableName,columnMap,invalidateKeys);  }    /**   * Add document infomation on table.   * @param uid documentuid   * @param onDelete if the document delete from Amazon CloudSearch, set true.   * @param sdfData document SDF data.   * @throws ManifoldCFException   */  public void addDocument(String uid, boolean onDelete, String sdfData)       throws ManifoldCFException  {    ArrayList params = new ArrayList();    params.add(uid);    IResultSet set = performQuery("SELECT * FROM "+getTableName()+" WHERE "+        UID_FIELD+"=?",params,null,null);        Map<String,String> parameterMap = new HashMap<String,String>();    parameterMap.put(UID_FIELD, uid);    if(onDelete)    {      parameterMap.put(ON_DELETE_FIELD, "1");    }    else     {      parameterMap.put(ON_DELETE_FIELD, "0");    }    parameterMap.put(SDF_DATA_FIELD, sdfData);        //if record exists on table, update record.    if(set.getRowCount() > 0)    {      List<String> whereParameters = new ArrayList<String>();      whereParameters.add(uid);      performUpdate(parameterMap, " WHERE "+UID_FIELD+"=?", whereParameters, null);    }    else    {      performInsert(parameterMap, null);    }  }    /**   * get document chunk number.   * @return number of document chunk.   * @throws ManifoldCFException   */  public int getDocumentChunkNum() throws ManifoldCFException{    String query = "select count(*) as COUNT from " + tableName;    IResultSet resultset = performQuery(query, null, null, null);    Object value = resultset.getRow(0).getValue("count");    if(value == null)    {      return 0;    }        int count = (Integer)value;    if(count <= 0)    {      return 0;    }    else    {      return (count/MAX_DOCNUM_IN_CHUNK)+1;    }  }    /**   * build document chunk (sdf formatted) from Table with chunkid which is given.   * @param chunkid    * @return document chunk (sdf formatted)   * @throws ManifoldCFException    */  public String buildDocumentChunk(String chunkid, int chunkIdx) throws ManifoldCFException  {    int idxFrom = chunkIdx * MAX_DOCNUM_IN_CHUNK;    int idxTo = idxFrom + MAX_DOCNUM_IN_CHUNK;        String query = "SELECT * FROM ("        + "SELECT ROW_NUMBER() OVER() as RN, "         + UID_FIELD +", " + ON_DELETE_FIELD + ", " + SDF_DATA_FIELD         + " FROM " + tableName        + " ORDER BY " + UID_FIELD +" ) "        + "as E WHERE E.RN BETWEEN " + idxFrom         + " AND "+ idxTo;        IResultSet resultset = performQuery(query, null, null, null);        int currentSize = 0;    StringBuffer sdfChunk = new StringBuffer();    List<String> uidListInChunk = new ArrayList<String>();    for(int i=0;i<resultset.getRowCount();i++)    {      IResultRow result = resultset.getRow(i);      String uidValue = (String)result.getValue(UID_FIELD);      String onDeleteValue = (String)result.getValue(ON_DELETE_FIELD);      String sdfValue = (String)result.getValue(SDF_DATA_FIELD);            // if sdf size is over max size, break the loop.       currentSize = currentSize + sdfValue.getBytes().length;      if(currentSize > MAX_DOCBYTES_IN_CHUNK)      {        break;      }            //append sdf value to chunk.      sdfChunk.append(sdfValue);      uidListInChunk.add(uidValue);    }        uidMap.put(chunkid, uidListInChunk);    return sdfChunk.toString();  }    /**   * remvoe documents in chunk.   * @param chunkid   * @throws ManifoldCFException   */  public void removeDocumentsInChunk(String chunkid)    throws ManifoldCFException  {    List<String> uidList = uidMap.get(chunkid);    for(String uid : uidList)    {      List<String> param = new ArrayList<String>();      param.add(uid);      performDelete("WHERE " + UID_FIELD + "=?", param, null);    }    uidMap.remove(chunkid);  }}